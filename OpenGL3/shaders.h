//This file was automatically generated with a batch file and C# script with .glsl files as a source
//Both the script file and shaders used can be found in the data/Shaders folder of the projects working directory
#pragma once
const char * FontFragment=
"#version 330 core\n"
"in vec2 frag_uv;\n"
"uniform sampler2D Text;\n"
"uniform vec4 Color;\n"
"uniform float iTime;\n"
"out vec4 FragColor;\n"
"void main()\n"
"{ \n"
"    vec4 FillColor = Color;\n"
"    // if(Color.w == -1.0){\n"
"    //     FillColor = vec4(0.5 + 0.5*cos(iTime * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"    // }\n"
"\n"
"\n"
"    float a =  texture(Text, frag_uv ).a;\n"
"    clamp(a, 0.0, 1.0);\n"
"\n"
"FragColor = vec4(FillColor.xyz, a  + 0.0);\n"
"\n"
"   // FragColor = vec4(FillColor.xyz, texture(Text, frag_uv).x - (1.0-FillColor.w) + 0.3);\n"
"};\n"
"\n"
"\n"
"//BENCHMARKS for 100 * 112 letters :\n"
"//40 ms: unchanged\n"
"//35 ms: removed vec2 floor\n"
"//28 ms: precomputed text length\n"
"//15 ms: locally alocated text data from string to char*\n"
"//13 ms: pre allocated final position and scale floats, removed needless vec2\n"
"//12 ms: inlined uneeded checkFont function\n"
"//2 ms: switched to an instancing pipline\n"
"\n"
"\n"
;const char * FontVertex=
"#version 330 core\n"
"layout (location = 1) in vec3 aPos;\n"
"layout (location = 5) in vec4 aTrans;\n"
"layout (location = 6) in vec4 uvOff;\n"
"\n"
"uniform float aspect;\n"
"uniform vec2 scaleOffset; //UVs\n"
"uniform vec2 scale; //UVs\n"
"uniform mat4 xform;\n"
"uniform vec2 zoom;\n"
"uniform vec2 position;\n"
"uniform float rotation;\n"
"\n"
"uniform vec2 posOffset;\n"
"out vec2 frag_uv;\n"
"\n"
"mat4 localTransform(){\n"
"    //local letter position\n"
"    float lx = aTrans.x / aspect;\n"
"    float ly = aTrans.y;\n"
"\n"
"    //local letter scale\n"
"    float sx = aTrans.z / aspect;\n"
"    float sy = aTrans.a;\n"
"\n"
"    mat4 localTranslation = \n"
"    mat4(1.0, 0.0, 0.0,  0.0,\n"
"         0.0, 1.0, 0.0,  0.0,\n"
"         0.0, 0.0, 1.0,  0.0,\n"
"         lx,  ly,  0.0,  1.0);\n"
"    mat4 scale = \n"
"    mat4(sx,  0.0, 0.0,  0.0,\n"
"         0.0, sy * ((zoom.y < 0.0) ? -1.0 : 1.0),  0.0,  0.0,\n"
"         0.0, 0.0, 1.0,  0.0,\n"
"         0.0, 0.0, 0.0,  1.0);\n"
"    return (localTranslation * scale);\n"
"}\n"
"\n"
"mat4 globalTransform(){     \n"
"    //global shape position\n"
"    float px = position.x; \n"
"    float py = position.y;\n"
"\n"
"    float s = sin(-rotation);\n"
"    float c = cos(-rotation);\n"
"\n"
"mat4 globalTranslation = \n"
"    mat4(1.0, 0.0, 0.0,  0.0,\n"
"         0.0, 1.0, 0.0,  0.0,\n"
"         0.0, 0.0, 1.0,  0.0,\n"
"         px,  py,  0.0,  1.0);\n"
"\n"
"    //aspect scale\n"
"mat4 Ascale = \n"
"    mat4(aspect, 0.0,  0.0,  0.0,\n"
"         0.0, 1.0,  0.0,  0.0,\n"
"         0.0, 0.0,  1.0,  0.0,\n"
"         0.0, 0.0,  0.0,  1.0);\n"
"    //global rotation\n"
"mat4 rotation = \n"
"    mat4(c,  -s,  0.0, 0.0,\n"
"        s,   c,  0.0, 0.0,\n"
"        0.0, 0.0, 1.0, 0.0,\n"
"        0.0, 0.0, 0.0, 1.0);\n"
"   return (globalTranslation * Ascale * rotation);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\n"
"mat4 camZoom = mat4( zoom.x,  0.0,  0.0, 0.0,\n"
"                     0.0, zoom.y,  0.0, 0.0,\n"
"                     0.0, 0.0, 1.0, 0.0,\n"
"                     0.0, 0.0, 0.0, 1.0);\n"
"\n"
"    mat4 globalT;\n"
"    if(xform[0][0] == 0)\n"
"        globalT = globalTransform();\n"
"    else\n"
"        globalT = xform;\n"
"\n"
"   vec4 ndcPos = camZoom * globalT * localTransform() * vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
"        frag_uv = aPos.xy * (uvOff.zw) + (uvOff.xy);\n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * ParticleFragment=
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec4 Color;\n"
"uniform sampler2D Text;\n"
"out vec4 FragColor;\n"
"uniform float UVScale;\n"
"\n"
"void main()\n"
"{\n"
"    if(UVScale ==0){\n"
"        float f =  smoothstep(0.0, 0.5, length(frag_uv  -0.5));\n"
"        vec4 c = vec4(Color.xyz, 1.0 -f);//-f + FillColor.w);\n"
"        FragColor = c;\n"
"        return;\n"
"    }\n"
"    FragColor = vec4(texture(Text, frag_uv));\n"
"}\n"
"\n"
;const char * ParticleVertex=
"#version 330 core\n"
"\n"
"layout (location = 1) in vec3 aPos;\n"
"layout (location = 2) in vec3 aOffset;\n"
"layout (location = 3) in vec4 aColor;\n"
"layout (location = 4) in vec2 UVoffset;\n"
"\n"
"uniform vec2 position;\n"
"uniform vec2 iResolution;\n"
"uniform float UVScale;\n"
"uniform mat4 xform;\n"
"\n"
"out vec2 frag_uv;\n"
"out vec4 Color;\n"
"\n"
"void main()\n"
"{\n"
"    //scale\n"
"    vec2 pos = vec2(aPos.x, aPos.y) * ( vec2(aOffset.z * 2.0) / (iResolution / 2.0));\n"
"    //local translation\n"
"    pos += aOffset.xy / (iResolution / 2.0);\n"
"    //global translation\n"
"    pos += position / (iResolution / 2.0);\n"
"\n"
"    vec4 ndcPos = vec4(pos.x, pos.y, 0.0, 1.0);  \n"
"    \n"
"    //if no texture\n"
"    if(UVScale == 0)\n"
"        frag_uv = aPos.xy * 0.5 + 0.5;\n"
"    else\n"
"        frag_uv = aPos.xy * (UVScale / 2) + vec2(1.0 - UVoffset.x, UVoffset.y);\n"
"    Color = aColor;\n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * PolygonFragment=
"#version 330 core\n"
"\n"
"#define PI 3.14159265359\n"
"#define TWO_PI 6.28318530718\n"
"\n"
"in vec2 frag_uv;\n"
"uniform vec4 Color;\n"
"uniform vec4 bordColor;\n"
"uniform vec2 shapeScale;\n"
"uniform int sideCount;\n"
"uniform float bordWidth;\n"
"uniform vec2 zoom;\n"
"uniform float iTime;\n"
"uniform float rotation; //needed to skip anti aliasing with rects with no rotation\n"
"out vec4 FragColor;\n"
"\n"
"//scaling and position a #sided polygon precisely within a square based off an equation is impossible, but I've hard coded the first 32\n"
"//https://www.desmos.com/calculator/rjo0sbq3wh\n"
"float polyOffs[30] = float[] (0.36, 0.5, 0.45, 0.5, 0.475,0.5, 0.484, 0.5,\n"
"                          0.49, 0.5, 0.492, 0.5, 0.495, 0.5, 0.495, 0.5,\n"
"                          0.497, 0.5, 0.497, 0.5, 0.498, 0.5, 0.498, 0.5,\n"
"                          0.499, 0.5, 0.499, 0.5, 0.499, 0.5);\n"
"\n"
"float polyRads[30] = float[] (0.289, 0.5, 0.423, 0.433, 0.465, 0.5, 0.476, 0.475, \n"
"                         0.484, 0.5, 0.489, 0.487, 0.492, 0.5, 0.493, 0.492, \n"
"                         0.494, 0.5, 0.495, 0.495, 0.496, 0.5, 0.497, 0.497,\n"
"                         0.498, 0.5, 0.498, 0.498, 0.498, 0.5);\n"
"\n"
"\n"
"mat2 rot(float a){\n"
"    return mat2(\n"
"        sin(a),cos(a),\n"
"        cos(a),-sin(a)\n"
"        );\n"
"}\n"
"\n"
"//delux anti aliasing\n"
"float aastep(float threshold, float value) {\n"
"  #ifdef GL_OES_standard_derivatives\n"
"    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n"
"    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n"
"  #else\n"
"    return step(threshold, value);\n"
"  #endif  \n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    float xblur = 1.5/shapeScale.x;\n"
"	float yblur = 1.5/shapeScale.y;\n"
"    \n"
"    //get fancy colors and patterns\n"
"    vec4 FillColor = Color;\n"
"    vec4 BorderColor = bordColor;\n"
"    if(Color.a < 0.0)\n"
"    {\n"
"        if(Color.a == -1.0)\n"
"            FillColor = vec4(0.5 + 0.5*cos(iTime * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"        if(Color.a == -2.0){\n"
"            vec2 uv = vec2(1.0) * ((frag_uv * zoom) * shapeScale.xy) * rot(-0.78539816339);\n"
"            vec3 hc = mix(vec3(0.5), vec3(1), step(0.5, sin((uv.x + iTime * 0.006) *800.0)+0.5));\n"
"            FillColor = vec4(hc, 1.0);\n"
"        }\n"
"    }\n"
"\n"
"    if(bordColor.a < 0.0)\n"
"    {\n"
"        if(bordColor.a == -1.0)\n"
"            BorderColor = vec4(0.5 + 0.5*cos((iTime + 300.0) * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"        if(Color.a == -2.0){\n"
"            vec2 uv = vec2(1.0) * (frag_uv * zoom) * rot(-0.78539816339);\n"
"            vec3 hc = mix(vec3(0.5), vec3(1), step(0.5, sin((uv.x * + (iTime + 20.0) * 0.2) *40.0)+0.5));\n"
"            BorderColor  = vec4(hc, 1.0);\n"
"        }\n"
"    }\n"
"\n"
"    //rect\n"
"    if(sideCount == 4){\n"
"        float bordX = (bordWidth / shapeScale.x);\n"
"        float bordy = (bordWidth / shapeScale.y);\n"
"\n"
"        //there can be anti aliasing artifacts if the angle is zero, so just skip it\n"
"        if(rotation == 0)\n"
"        {\n"
"            vec4 c = vec4(BorderColor.xyz, BorderColor.w);\n"
"            if(\n"
"                frag_uv.x > bordX &&\n"
"                frag_uv.x < 1.0 - bordX &&\n"
"                frag_uv.y > bordy &&\n"
"                frag_uv.y < 1.0 - bordy\n"
"            )\n"
"                c = FillColor;\n"
"            FragColor = c;\n"
"            return;\n"
"        }\n"
"\n"
"        float vx = 1.0 / shapeScale.x;\n"
"        float vy = 1.0 / shapeScale.y;\n"
"        vec2 uv = vec2(aastep(vx, frag_uv.x), aastep(vx, frag_uv.y));\n"
"        uv *= vec2(aastep(vy, 1.0 - frag_uv.x), aastep(vy, 1.0 - frag_uv.y));    \n"
"        float f = uv.x * uv.y;\n"
"\n"
"        vec4 c = vec4(BorderColor.xyz, BorderColor.w - (1.0 - f));\n"
"\n"
"        uv = vec2(aastep( bordX, frag_uv.x), aastep(bordy, frag_uv.y));\n"
"        uv *= vec2(aastep(bordX, 1.0 - frag_uv.x), aastep(bordy, 1.0 - frag_uv.y));\n"
"        f = uv.x * uv.y;\n"
"\n"
"        FragColor = mix(c, FillColor, f);       \n"
"        return;\n"
"    }\n"
"\n"
"    //elipse\n"
"    if(sideCount == 1){      \n"
"        float f; \n"
"        float af = fwidth(length(frag_uv - 0.5));  \n"
"        vec4 c = vec4(FillColor.xyz, 0.0);\n"
"        if(bordWidth > 0){         \n"
"            f = 1.0 - aastep(0.5,  length(frag_uv - 0.5));  //f = smoothstep(0.5, 0.5 - af, length(frag_uv - 0.5));\n"
"            c = vec4(BorderColor.xyz, BorderColor.w - (1.0 - f));\n"
"        }\n"
"\n"
"        float bord = bordWidth / shapeScale.x;\n"
"        f = 1.0 - aastep(0.5 - bord, length(frag_uv - 0.5)); //smoothstep(0.5 - bord, 0.5 - bord - af, length(frag_uv - 0.5));\n"
"        FragColor = mix(c, FillColor, f);\n"
"        return;\n"
"    }\n"
"\n"
"    //polygon\n"
"    // float yoff = 0.5;\n"
"    // float rad = 0.5;\n"
"    // if(sideCount < 33){\n"
"    //     yoff = polyOffs[sideCount -3];\n"
"    //     rad = polyRads[sideCount -3];\n"
"    // }\n"
"\n"
"    // vec2 st = frag_uv - vec2(0.5, yoff);//(frag_uv - 0.5) * 2.0;\n"
"    // float angle = atan(st.x,st.y) + PI;\n"
"    // float slice = TWO_PI / sideCount;\n"
"    // float f = aastep(rad, cos(floor(0.5 + angle / slice ) * slice - angle) * length(st));\n"
"\n"
"    // vec4 c = vec4(BorderColor.xyz, BorderColor.w - (1.0 - f));\n"
"    // rad -= bordWidth / shapeScale.x;\n"
"    \n"
"    // angle = atan(st.x,st.y) + PI;\n"
"    // slice = TWO_PI / sideCount;\n"
"    // f = aastep(rad, cos(floor(0.5 + angle / slice ) * slice - angle) * length(st));\n"
"    // vec4 d = vec4(FillColor.xyz, FillColor.w - (1.0 - f));\n"
"    // c = mix(c, d,  -f);\n"
"    \n"
"    float yoff = 0.5;\n"
"    float rad = 0.5;\n"
"    if(sideCount < 33){\n"
"        yoff = polyOffs[sideCount -3];\n"
"        rad = polyRads[sideCount -3];\n"
"    }\n"
"\n"
"    vec2 uv = frag_uv - vec2(0.5, yoff);\n"
"    float a = atan(uv.x,uv.y)+PI;\n"
"    float r = TWO_PI/float(sideCount);\n"
"    float d = cos(floor(.5+a/r)*r-a)*length(uv);\n"
"    float f = -smoothstep(rad- xblur, rad,d);\n"
"\n"
"    vec4 c = vec4(BorderColor.xyz, 1.0 + f);\n"
"    rad -= bordWidth / shapeScale.x;\n"
"\n"
"    a = atan(uv.x,uv.y)+PI;\n"
"    r = TWO_PI/float(sideCount);\n"
"    d = cos(floor(.5+a/r)*r-a)*length(uv);\n"
"    f = -smoothstep(rad- xblur, rad,d);\n"
"    c = mix(c, FillColor, 1.0 + f);\n"
"\n"
"    FragColor = c;\n"
"}\n"
;const char * RectVertex=
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform float aspect;\n"
"uniform mat4 xform;\n"
"uniform vec2 scale;\n"
"uniform vec2 position;\n"
"uniform float rotation;\n"
"uniform vec2 zoom;\n"
"out vec2 frag_uv;\n"
"\n"
"mat4 trans(){\n"
"    float sx = scale.x;\n"
"    float sy = scale.y;\n"
"     \n"
"    float px = position.x;\n"
"    float py = position.y;\n"
"\n"
"    float s = sin(-rotation);\n"
"    float c = cos(-rotation);\n"
"\n"
"    //translation\n"
"mat4 tran = mat4(1.0, 0.0, 0.0,  0.0,\n"
"                 0.0, 1.0, 0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 px,  py,  0.0,  1.0);\n"
"\n"
"    //aspect scale\n"
"mat4 ascal = mat4(aspect, 0.0,  0.0,  0.0,\n"
"                     0.0, 1.0,  0.0,  0.0,\n"
"                     0.0, 0.0,  1.0,  0.0,\n"
"                     0.0, 0.0,  0.0,  1.0);\n"
"\n"
"    //scale\n"
"mat4 scal = mat4(sx,  0.0, 0.0,  0.0,\n"
"                 0.0, sy,  0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 0.0, 0.0, 0.0,  1.0);\n"
"    //rotation\n"
"mat4 rot = mat4( c,  -s,  0.0, 0.0,\n"
"                 s,   c,  0.0, 0.0,\n"
"                0.0, 0.0, 1.0, 0.0,\n"
"                0.0, 0.0, 0.0, 1.0);\n"
"    return (tran * ascal * rot * scal);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec4 ndcPos;\n"
"\n"
"mat4 camZoom = mat4( zoom.x,  0.0,  0.0, 0.0,\n"
"                     0.0,   zoom.y,  0.0, 0.0,\n"
"                     0.0, 0.0, 1.0, 0.0,\n"
"                     0.0, 0.0, 0.0, 1.0);\n"
"\n"
"    if(xform[0][0] == 0)\n"
"        ndcPos = camZoom * trans() * vec4(aPos.x / aspect, aPos.y, aPos.z, 1.0);    \n"
"    else\n"
"        ndcPos =  (camZoom * xform * vec4(aPos.x / aspect, aPos.y, aPos.z, 1.0));\n"
"\n"
"    frag_uv = aPos.xy *0.5 + 0.5; \n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * SetPixelFragment=
"#version 330 core\n"
"in vec2 frag_uv;\n"
"uniform sampler2D Text;\n"
"// uniform sampler2D Mask;\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   vec4 texCol = vec4(texture(Text, frag_uv));\n"
"  // float textMask = vec4(texture(Mask, frag_uv)).r;\n"
" //  texCol.a *= textMask;\n"
"   FragColor =  texCol;\n"
"};\n"
"\n"
"\n"
;const char * simpleRect=
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform float aspect;\n"
"out vec2 frag_uv;\n"
"\n"
"void main()\n"
"{\n"
"    vec4 ndcPos =  vec4(aPos.x , aPos.y, aPos.z, 1.0);    \n"
"    frag_uv = aPos.xy *0.5 + 0.5; \n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * TextureFragment=
"#version 330 core\n"
"in vec2 frag_uv;\n"
"uniform sampler2D Text;\n"
"uniform vec4 tint;\n"
"uniform float opacity;\n"
"uniform vec2 scaleOffset;\n"
"uniform vec2 posOffset;\n"
"uniform vec2 zoom;\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   vec4 texCol;\n"
"   if(zoom.y >= 0)\n"
"      texCol = vec4(texture(Text, frag_uv * scaleOffset + posOffset));\n"
"   else\n"
"      texCol = vec4(texture(Text, (1.0 -frag_uv) * scaleOffset + posOffset));\n"
"\n"
"   texCol.a *= opacity;\n"
"   FragColor = mix(texCol, vec4(tint.rgb, 1.0), texCol.a * tint.a);\n"
"};\n"
"\n"
"\n"
"\n"
;