//This file was automatically generated with a batch file and C# script with .glsl files as a source
//Both the script file and shaders used can be found in the data/Shaders folder of the projects working directory
#pragma once
const char * FontFragment=
"#version 330 core\n"
"in vec2 frag_uv;\n"
"uniform sampler2D Text;\n"
"uniform vec4 Color;\n"
"uniform float iTime;\n"
"out vec4 FragColor;\n"
"void main()\n"
"{ \n"
"    vec4 FillColor = Color;\n"
"    if(Color.w == -1.0){\n"
"        FillColor = vec4(0.5 + 0.5*cos(iTime * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"    }\n"
"    FragColor =  vec4(FillColor.xyz, texture(Text, frag_uv).x - (1.0-FillColor.w));\n"
"};\n"
"\n"
"\n"
"//BENCHMARKS:\n"
"//40 ms: unchanged\n"
"//35 ms: removed vec2 floor\n"
"//28 ms: precomputed text length\n"
"//15 ms: locally alocated text data from string to char*\n"
"//13 ms: pre allocated final position and scale floats, removed needless vec2\n"
"//12 ms: inlined uneaded checkFont function\n"
"\n"
"\n"
;const char * FontVertex=
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform float aspect;\n"
"uniform vec2 scaleOffset;\n"
"uniform vec2 scale;\n"
"uniform vec2 position;\n"
"uniform float rotation;\n"
"\n"
"uniform vec2 posOffset;\n"
"out vec2 frag_uv;\n"
"\n"
"mat4 trans(){\n"
"    float sx = scale.x;\n"
"    float sy = scale.y;\n"
"     \n"
"    float px = position.x;\n"
"    float py = position.y;\n"
"\n"
"    float s = sin(-rotation);\n"
"    float c = cos(-rotation);\n"
"\n"
"    //translation\n"
"mat4 tran = mat4(1.0, 0.0, 0.0,  0.0,\n"
"                 0.0, 1.0, 0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 px,  py,  0.0,  1.0);\n"
"\n"
"    //aspect scale\n"
"mat4 ascal = mat4(aspect, 0.0,  0.0,  0.0,\n"
"                     0.0, 1.0,  0.0,  0.0,\n"
"                     0.0, 0.0,  1.0,  0.0,\n"
"                     0.0, 0.0,  0.0,  1.0);\n"
"\n"
"    //scale\n"
"mat4 scal = mat4(sx,  0.0, 0.0,  0.0,\n"
"                 0.0, sy,  0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 0.0, 0.0, 0.0,  1.0);\n"
"    //rotation\n"
"mat4 rot = mat4( c,  -s,  0.0, 0.0,\n"
"                 s,   c,  0.0, 0.0,\n"
"                0.0, 0.0, 1.0, 0.0,\n"
"                0.0, 0.0, 0.0, 1.0);\n"
"   // return (tran * ascal * rot * scal);\n"
"    return (tran * ascal * rot * scal);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   vec4 ndcPos = trans() * vec4(aPos.x / aspect, aPos.y, aPos.z, 1.0);\n"
"        frag_uv = aPos.xy *scaleOffset + posOffset;\n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * ParticleFragment=
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec4 Color;\n"
"out vec4 FragColor;\n"
"\n"
"void main()\n"
"{\n"
"    float f =  smoothstep(0.0, 0.1, length(frag_uv  -0.5));\n"
"    vec4 c = vec4(Color.xyz, 1.0 -f);//-f + FillColor.w);\n"
"\n"
"    FragColor = c;\n"
"}\n"
"\n"
;const char * ParticleVertex=
"#version 330 core\n"
"\n"
"layout (location = 1) in vec3 aPos;\n"
"layout (location = 2) in vec3 aOffset;\n"
"layout (location = 3) in vec4 aColor;\n"
"\n"
"uniform vec2 position;\n"
"uniform vec2 iResolution;\n"
"\n"
"out vec2 frag_uv;\n"
"out vec4 Color;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 pos = vec2(aPos.x, aPos.y) * ( vec2(aOffset.z * 2.0) / (iResolution / 2.0));\n"
"    pos += aOffset.xy / (iResolution / 2.0);\n"
"    pos += position / (iResolution / 2.0);\n"
"    vec4 ndcPos = vec4(pos.x, pos.y, 0.0, 1.0);  // vec4(aPos.x * aOffset.z, aPos.y * aOffset.z, 0.0, 1.0) + vec4(aOffset.x, aOffset.y, 0.0, 0.0);\n"
"        frag_uv = aPos.xy;// *0.5 + 0.5;\n"
"        Color = aColor;\n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * PolygonFragment=
"#version 330 core\n"
"\n"
"#define PI 3.14159265359\n"
"#define TWO_PI 6.28318530718\n"
"\n"
"in vec2 frag_uv;\n"
"uniform vec4 Color;\n"
"uniform vec4 bordColor;\n"
"uniform vec2 shapeScale;\n"
"uniform int sideCount;\n"
"uniform float bordWidth;\n"
"uniform float iTime;\n"
"uniform sampler2D Text;\n"
"out vec4 FragColor;\n"
"\n"
"//scaling and position a #sided polygon precisely within a square based off an equation is impossible, but I've hard coded the first 32\n"
"//https://www.desmos.com/calculator/rjo0sbq3wh\n"
"float polyOffs[30] = float[] (0.36, 0.5, 0.45, 0.5, 0.475,0.5, 0.484, 0.5,\n"
"                          0.49, 0.5, 0.492, 0.5, 0.495, 0.5, 0.495, 0.5,\n"
"                          0.497, 0.5, 0.497, 0.5, 0.498, 0.5, 0.498, 0.5,\n"
"                          0.499, 0.5, 0.499, 0.5, 0.499, 0.5);\n"
"\n"
"float polyRads[30] = float[] (0.289, 0.5, 0.423, 0.433, 0.465, 0.5, 0.476, 0.475, \n"
"                         0.484, 0.5, 0.489, 0.487, 0.492, 0.5, 0.493, 0.492, \n"
"                         0.494, 0.5, 0.495, 0.495, 0.496, 0.5, 0.497, 0.497,\n"
"                         0.498, 0.5, 0.498, 0.498, 0.498, 0.5);\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    float xblur = 1.5/shapeScale.x;\n"
"	float yblur = 1.5/shapeScale.y;\n"
"    \n"
"    vec4 FillColor = Color;\n"
"    vec4 BorderColor = bordColor;\n"
"    if(Color.w == -1.0){\n"
"        FillColor = vec4(0.5 + 0.5*cos(iTime * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"    }\n"
"    if(bordColor.w == -1.0){\n"
"        BorderColor = vec4(0.5 + 0.5*cos((iTime + 300.0) * 1.4 +(frag_uv).xyx+vec3(0,2,4)), 1.0);\n"
"    }\n"
"    \n"
"    if(sideCount == 4){\n"
"        float f =  smoothstep(1.0 - xblur, 1.0, frag_uv.x);\n"
"        f += smoothstep(xblur, 0.0, frag_uv.x);\n"
"        f +=  smoothstep(1.0 - yblur, 1.0, frag_uv.y);\n"
"        f += smoothstep(yblur, 0.0, frag_uv.y);\n"
"\n"
"        vec4 c = vec4(FillColor.xyz, -f + FillColor.w);\n"
"\n"
"        float bx = (bordWidth / shapeScale.x);\n"
"        float by = (bordWidth / shapeScale.y);\n"
"        if(bordWidth > 0){\n"
"            f =  smoothstep(1.0 - xblur - bx, 1.0 - bx, frag_uv.x);\n"
"            f += smoothstep(xblur+ bx, 0.0 + bx, frag_uv.x);\n"
"            f +=  smoothstep(1.0 - by - yblur, 1.0 - by, frag_uv.y);\n"
"            f += smoothstep(yblur + by, 0.0 + by, frag_uv.y);\n"
"            \n"
"            f = clamp(f, 0.0, 1.0);\n"
"            c = mix(c, BorderColor, f);\n"
"        }\n"
"        \n"
"        FragColor = vec4(c);\n"
"        return;\n"
"    }\n"
"    if(sideCount == 1){\n"
"\n"
"		float f =  smoothstep(0.5 - xblur, 0.5, length(frag_uv  -0.5));\n"
"        vec4 c = vec4(FillColor.xyz, -f + FillColor.w);\n"
"\n"
"        f =  smoothstep(0.5 - (bordWidth/shapeScale.x) - xblur, 0.5 - (bordWidth/shapeScale.x), length(frag_uv  -0.5));\n"
"        f -=  smoothstep(0.5 - xblur, 0.5, length(frag_uv  -0.5));\n"
"        c = mix(c, BorderColor, f);\n"
"\n"
"		FragColor = c;\n"
"        return;\n"
"    }\n"
"    if(sideCount == 0){\n"
"         FragColor = vec4(texture(Text, frag_uv));\n"
"         return;\n"
"    }\n"
"    if(sideCount == -1){\n"
"        FragColor = vec4(FillColor.xyz, texture(Text, frag_uv).x - (1.0-FillColor.w));\n"
"        return;\n"
"    }\n"
"\n"
"    float yoff;\n"
"    float rad;\n"
"    if(sideCount < 33){\n"
"        yoff = polyOffs[sideCount -3];\n"
"        rad = polyRads[sideCount -3];\n"
"    }\n"
"\n"
"    vec2 uv = frag_uv - vec2(0.5, yoff);\n"
"\n"
"    float a = atan(uv.x,uv.y)+PI;\n"
"    float r = TWO_PI/float(sideCount);\n"
"    float d = cos(floor(.5+a/r)*r-a)*length(uv);\n"
"    float f = -smoothstep(rad- xblur, rad,d);\n"
"\n"
"    vec4 c = vec4(BorderColor.xyz, 1.0 + f);\n"
"\n"
"    rad -= bordWidth / shapeScale.x;\n"
"\n"
"    a = atan(uv.x,uv.y)+PI;\n"
"    r = TWO_PI/float(sideCount);\n"
"    d = cos(floor(.5+a/r)*r-a)*length(uv);\n"
"    f = -smoothstep(rad- xblur, rad,d);\n"
"    c = mix(c, FillColor, 1.0 + f);\n"
"\n"
"    FragColor =c ;\n"
"}\n"
;const char * RectVertex=
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"uniform float aspect;\n"
"uniform vec2 scaleOffset;\n"
"uniform mat4 xform;\n"
"uniform vec2 scale;\n"
"uniform vec2 position;\n"
"uniform float rotation;\n"
"\n"
"uniform vec2 posOffset;\n"
"out vec2 frag_uv;\n"
"\n"
"mat4 trans(){\n"
"    float sx = scale.x;\n"
"    float sy = scale.y;\n"
"     \n"
"    float px = position.x;\n"
"    float py = position.y;\n"
"\n"
"    float s = sin(-rotation);\n"
"    float c = cos(-rotation);\n"
"\n"
"    //translation\n"
"mat4 tran = mat4(1.0, 0.0, 0.0,  0.0,\n"
"                 0.0, 1.0, 0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 px,  py,  0.0,  1.0);\n"
"\n"
"    //aspect scale\n"
"mat4 ascal = mat4(aspect, 0.0,  0.0,  0.0,\n"
"                     0.0, 1.0,  0.0,  0.0,\n"
"                     0.0, 0.0,  1.0,  0.0,\n"
"                     0.0, 0.0,  0.0,  1.0);\n"
"\n"
"    //scale\n"
"mat4 scal = mat4(sx,  0.0, 0.0,  0.0,\n"
"                 0.0, sy,  0.0,  0.0,\n"
"                 0.0, 0.0, 1.0,  0.0,\n"
"                 0.0, 0.0, 0.0,  1.0);\n"
"    //rotation\n"
"mat4 rot = mat4( c,  -s,  0.0, 0.0,\n"
"                 s,   c,  0.0, 0.0,\n"
"                0.0, 0.0, 1.0, 0.0,\n"
"                0.0, 0.0, 0.0, 1.0);\n"
"    return (tran * ascal * rot * scal);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   vec4 ndcPos = trans() *  vec4(aPos.x / aspect, aPos.y, aPos.z, 1.0);\n"
"        frag_uv = aPos.xy *0.5 + 0.5; //*scaleOffset + posOffset;\n"
"   gl_Position = ndcPos;\n"
"}\n"
;const char * TextureFragment=
"#version 330 core\n"
"in vec2 frag_uv;\n"
"uniform sampler2D Text;\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   FragColor = vec4(texture(Text, frag_uv));\n"
"};\n"
"\n"
"\n"
"\n"
;